# Todoist-like TODO Application Implementation Plan

## Project Overview and Architecture

This comprehensive implementation plan details building a production-ready TODO application with all Todoist features except recurring tasks. The application uses a modern tech stack with Passkey-only authentication, featuring a React frontend, Hono backend, and PostgreSQL database, all deployable via Docker Compose on home servers.

**Core Technology Stack:**

- **Frontend**: Vite + React + TanStack Router + shadcn/ui + OpenAPI TypeScript + TanStack Query
- **Backend**: Hono + PostgreSQL + Passkey authentication (WebAuthn/FIDO2) + Hono OpenAPI + Valibot
- **Deployment**: Docker Compose for home server deployment
- **Package Manager**: Bun with workspaces monorepo structure

**Key Architecture Decisions:**

- **Passkey-first authentication** eliminates password complexity while providing superior security
- **OpenAPI-driven development** ensures type safety between frontend and backend
- **Hierarchical data model** supports unlimited nesting of projects and tasks
- **Event-driven architecture** enables real-time updates and audit trails
- **Microservice-ready design** allows future scaling while maintaining monolith simplicity

## Database Schema Design

### Core Entity Model

The database schema centers on hierarchical relationships using PostgreSQL's recursive Common Table Expressions (CTEs) and LTREE extension for optimal performance.

```sql
-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS ltree;
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- Users and authentication
CREATE TABLE users (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    display_name VARCHAR(255) NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- WebAuthn credentials for passkey authentication
CREATE TABLE webauthn_credentials (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    credential_id BYTEA UNIQUE NOT NULL,
    public_key BYTEA NOT NULL,
    counter BIGINT DEFAULT 0,
    device_type VARCHAR(50) DEFAULT 'platform',
    backup_eligible BOOLEAN DEFAULT false,
    backup_state BOOLEAN DEFAULT false,
    transports TEXT[],
    aaguid UUID,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_used_at TIMESTAMPTZ,
    nickname VARCHAR(255)
);

-- Projects with hierarchical support
CREATE TABLE projects (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    parent_project_id BIGINT REFERENCES projects(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    color VARCHAR(7) DEFAULT '#808080',
    path LTREE,
    depth INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- Tasks with full hierarchy and priority support
CREATE TABLE tasks (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    project_id BIGINT NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    parent_task_id BIGINT REFERENCES tasks(id),
    title VARCHAR(500) NOT NULL,
    description TEXT,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    priority INTEGER NOT NULL DEFAULT 0,
    due_date TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    path LTREE,
    depth INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);

-- Labels/tags system
CREATE TABLE labels (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL,
    color VARCHAR(7) DEFAULT '#808080',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(user_id, name)
);

-- Task-label associations
CREATE TABLE task_labels (
    task_id BIGINT NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
    label_id BIGINT NOT NULL REFERENCES labels(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    PRIMARY KEY (task_id, label_id)
);

-- Comments/notes with polymorphic design
CREATE TABLE comments (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    commentable_type VARCHAR(50) NOT NULL,
    commentable_id BIGINT NOT NULL,
    parent_comment_id BIGINT REFERENCES comments(id),
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ
);
```

### Performance Optimization Indexes

```sql
-- Essential indexes for query performance
CREATE INDEX idx_projects_user_path ON projects USING GIST (user_id, path) WHERE deleted_at IS NULL;
CREATE INDEX idx_tasks_user_project ON tasks (user_id, project_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_tasks_path_gist ON tasks USING GIST (path) WHERE deleted_at IS NULL;
CREATE INDEX idx_tasks_due_date ON tasks (due_date) WHERE deleted_at IS NULL AND due_date IS NOT NULL;
CREATE INDEX idx_tasks_fts ON tasks USING GIN (to_tsvector('english', title || ' ' || COALESCE(description, '')));
CREATE INDEX idx_task_labels_task ON task_labels (task_id);
CREATE INDEX idx_comments_polymorphic ON comments (commentable_type, commentable_id) WHERE deleted_at IS NULL;
```

## API Endpoints Specification

### Authentication Endpoints

**WebAuthn Registration and Authentication:**

```typescript
// POST /auth/register/begin - Start passkey registration
POST /auth/register/begin
Request: { email: string, displayName: string }
Response: { challenge: string, rp: RelyingParty, user: UserInfo, ... }

// POST /auth/register/complete - Complete passkey registration
POST /auth/register/complete
Request: { credential: PublicKeyCredential }
Response: { user: User, token: string }

// POST /auth/authenticate/begin - Start passkey authentication
POST /auth/authenticate/begin
Request: { email?: string }
Response: { challenge: string, allowCredentials?: PublicKeyCredentialDescriptor[] }

// POST /auth/authenticate/complete - Complete passkey authentication
POST /auth/authenticate/complete
Request: { credential: PublicKeyCredential }
Response: { user: User, token: string }
```

### Core Resource Endpoints

**Projects Management:**

```typescript
// GET /api/projects - List user projects with hierarchy
GET /api/projects?include_archived=false&depth=3
Response: { projects: Project[], total: number }

// POST /api/projects - Create new project
POST /api/projects
Request: { name: string, description?: string, parent_id?: number, color?: string }
Response: { project: Project }

// GET /api/projects/:id - Get project with tasks
GET /api/projects/:id?include_tasks=true&include_completed=false
Response: { project: Project, tasks?: Task[] }

// PUT /api/projects/:id - Update project
PUT /api/projects/:id
Request: Partial<Project>
Response: { project: Project }

// DELETE /api/projects/:id - Archive project
DELETE /api/projects/:id
Response: { success: boolean }
```

**Tasks Management:**

```typescript
// GET /api/tasks - List tasks with filtering
GET /api/tasks?project_id=1&status=pending&labels=urgent,work&due_before=2025-01-01&search=meeting
Response: { tasks: Task[], total: number, page: number }

// POST /api/tasks - Create new task
POST /api/tasks
Request: { title: string, project_id: number, parent_id?: number, description?: string, priority?: number, due_date?: string, labels?: string[] }
Response: { task: Task }

// GET /api/tasks/:id - Get task with subtasks and comments
GET /api/tasks/:id?include_subtasks=true&include_comments=true
Response: { task: Task, subtasks?: Task[], comments?: Comment[] }

// PUT /api/tasks/:id - Update task
PUT /api/tasks/:id
Request: Partial<Task>
Response: { task: Task }

// POST /api/tasks/:id/complete - Mark task complete
POST /api/tasks/:id/complete
Response: { task: Task }

// DELETE /api/tasks/:id - Archive task
DELETE /api/tasks/:id
Response: { success: boolean }
```

**Labels and Comments:**

```typescript
// GET /api/labels - List user labels
GET /api/labels
Response: { labels: Label[] }

// POST /api/labels - Create label
POST /api/labels
Request: { name: string, color?: string }
Response: { label: Label }

// POST /api/tasks/:id/comments - Add comment
POST /api/tasks/:id/comments
Request: { content: string, parent_id?: number }
Response: { comment: Comment }
```

## Implementation Phases

### Phase 1: Foundation and Authentication (Weeks 1-2)

**Week 1 - Project Setup and Database**

- [ ] Initialize Bun workspace monorepo structure
- [ ] Set up Vite + React frontend with TypeScript
- [ ] Configure Hono backend with OpenAPI integration
- [ ] Create PostgreSQL database schema with migrations
- [ ] Set up Docker Compose development environment
- [ ] Configure Valibot schemas for API validation

**Week 2 - WebAuthn Implementation**

- [ ] Implement passkey registration flow with SimpleWebAuthn
- [ ] Build authentication middleware for Hono
- [ ] Create user management endpoints
- [ ] Set up JWT token handling for session management
- [ ] Implement credential management UI components
- [ ] Add challenge replay protection and security measures

**Deliverables:**

- Working authentication system with passkey support
- Database schema with proper indexing
- Basic API structure with OpenAPI documentation
- Docker development environment

### Phase 2: Core Task Management (Weeks 3-4)

**Week 3 - Projects and Tasks Backend**

- [ ] Implement hierarchical project CRUD operations
- [ ] Build task management endpoints with full CRUD
- [ ] Add hierarchical query support using LTREE
- [ ] Implement task status management and priority levels
- [ ] Create search and filtering endpoints with full-text search
- [ ] Add data validation with comprehensive Valibot schemas

**Week 4 - Frontend Task Management**

- [ ] Build project management interface with tree view
- [ ] Create task creation and editing forms
- [ ] Implement task list views with filtering and sorting
- [ ] Add drag-and-drop for task organization
- [ ] Build hierarchical navigation components
- [ ] Integrate TanStack Query for state management

**Deliverables:**

- Complete project and task management system
- Hierarchical data display and manipulation
- Search and filtering functionality
- Responsive UI components with shadcn/ui

### Phase 3: Advanced Features (Weeks 5-6)

**Week 5 - Labels, Comments, and Due Dates**

- [ ] Implement label system with color coding
- [ ] Build comment system for tasks and projects
- [ ] Add due date management with timezone support
- [ ] Create label filtering and management UI
- [ ] Implement comment threads with replies
- [ ] Add due date notifications and overdue highlighting

**Week 6 - Archive and Search**

- [ ] Implement soft delete for tasks and projects
- [ ] Build archive management interface
- [ ] Add advanced search with PostgreSQL full-text search
- [ ] Create search result highlighting
- [ ] Implement search history and saved searches
- [ ] Add bulk operations for task management

**Deliverables:**

- Complete labeling and commenting system
- Advanced search functionality
- Archive management
- Due date handling with notifications

### Phase 4: Testing and Polish (Weeks 7-8)

**Week 7 - Comprehensive Testing**

- [ ] Unit tests for all React components with React Testing Library
- [ ] Integration tests for API endpoints with database
- [ ] End-to-end tests for complete user workflows
- [ ] Passkey authentication flow testing with virtual authenticators
- [ ] Performance testing for hierarchical queries
- [ ] Cross-browser compatibility testing

**Week 8 - Production Preparation**

- [ ] Security audit and penetration testing
- [ ] Performance optimization and caching strategies
- [ ] Production Docker Compose configuration
- [ ] SSL certificate automation with Let's Encrypt
- [ ] Monitoring and logging implementation
- [ ] Database backup and recovery procedures

**Deliverables:**

- Comprehensive test suite with high coverage
- Production-ready deployment configuration
- Security hardened application
- Monitoring and backup systems

## Testing Strategy

### Unit Testing (70% Coverage Target)

**React Components with TanStack Query:**

```typescript
// Test utilities for query client setup
function createTestQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: { retry: false, gcTime: Infinity },
      mutations: { retry: false },
    },
  })
}

function renderWithQuery(ui, { queryClient = createTestQueryClient(), ...options } = {}) {
  return render(
    <QueryClientProvider client={queryClient}>{ui}</QueryClientProvider>,
    options
  )
}

// Component testing example
test('TaskList displays tasks and handles loading states', async () => {
  const mockTasks = [
    { id: 1, title: 'Test Task', status: 'pending' }
  ]

  server.use(
    http.get('/api/tasks', () => HttpResponse.json(mockTasks))
  )

  renderWithQuery(<TaskList projectId={1} />)

  expect(screen.getByText('Loading...')).toBeInTheDocument()

  await waitFor(() => {
    expect(screen.getByText('Test Task')).toBeInTheDocument()
  })
})
```

**API Endpoint Testing with Hono:**

```typescript
// Database transaction isolation for tests
const testDb = () => {
  return async (testFn) => {
    return pool.connect(async (client) => {
      try {
        await client.query("BEGIN");
        await testFn(client);
      } finally {
        await client.query("ROLLBACK");
      }
    });
  };
};

test("POST /api/tasks creates task in database", () => {
  return testDb(async (db) => {
    const response = await app.request("/api/tasks", {
      method: "POST",
      body: JSON.stringify({
        title: "New Task",
        project_id: 1,
      }),
      headers: { "Content-Type": "application/json" },
    });

    expect(response.status).toBe(201);

    const tasks = await db.query("SELECT * FROM tasks WHERE title = $1", [
      "New Task",
    ]);
    expect(tasks.rows).toHaveLength(1);
  });
});
```

### Integration Testing (20% Coverage)

**PostgreSQL Testcontainers Setup:**

```typescript
let container: PostgreSqlContainer;
let db: ReturnType<typeof drizzle>;

beforeAll(async () => {
  container = await new PostgreSqlContainer("postgres:16-alpine")
    .withDatabase("testdb")
    .withUsername("testuser")
    .withPassword("testpass")
    .start();

  const connectionString = container.getConnectionUri();
  const client = postgres(connectionString);
  db = drizzle(client);

  await migrate(db, { migrationsFolder: "./migrations" });
}, 30000);

afterAll(async () => {
  await container.stop();
});
```

### End-to-End Testing (10% Coverage)

**Playwright Passkey Authentication:**

```typescript
test.describe("Passkey Authentication Flow", () => {
  test.beforeEach(async ({ page }) => {
    await page.addVirtualAuthenticator({
      protocol: "webauthn",
      transport: "usb",
      hasResidentKey: true,
      hasUserVerification: true,
      isUserVerified: true,
    });
  });

  test("complete registration and authentication flow", async ({ page }) => {
    // Registration flow
    await page.goto("/auth/register");
    await page.fill('input[name="email"]', "test@example.com");
    await page.fill('input[name="displayName"]', "Test User");
    await page.click('button:has-text("Create Passkey")');

    await expect(page).toHaveURL("/dashboard");

    // Logout and re-authenticate
    await page.click('[data-testid="logout-button"]');
    await page.goto("/auth/login");
    await page.fill('input[name="email"]', "test@example.com");
    await page.click('button:has-text("Sign in with Passkey")');

    await expect(page).toHaveURL("/dashboard");
  });
});
```

## Security Considerations

### WebAuthn Implementation Security

**Challenge Management and Replay Protection:**

- Use cryptographically secure random challenges (minimum 32 bytes)
- Implement challenge expiration (5-10 minutes maximum)
- Store challenges server-side with single-use validation
- Validate origin headers to prevent phishing attacks

**Credential Storage Security:**

- Store public keys and metadata in PostgreSQL with proper encryption
- Implement counter-based replay protection for authenticators
- Use proper user handle generation (random bytes, not PII)
- Enable backup eligibility tracking for credential recovery

**Advanced Security Measures:**

```typescript
// Server-side credential verification
async function verifyAuthentication(credential, storedCredential, challenge) {
  // Validate origin
  const clientData = JSON.parse(
    Buffer.from(credential.response.clientDataJSON),
  );
  if (clientData.origin !== expectedOrigin) {
    throw new Error("Origin mismatch - potential phishing attempt");
  }

  // Verify challenge
  if (clientData.challenge !== challenge) {
    throw new Error("Challenge mismatch - potential replay attack");
  }

  // Counter validation for replay protection
  if (
    credential.response.authenticatorData.counter <= storedCredential.counter
  ) {
    throw new Error("Counter value indicates potential credential clone");
  }

  return verifySignature(credential, storedCredential.publicKey);
}
```

### Application Security Hardening

**Container Security:**

```dockerfile
# Use non-root user
RUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001
USER nodejs

# Read-only filesystem
RUN chmod -R 755 /app && chown -R nodejs:nodejs /app

# Security options in Docker Compose
security_opt:
  - no-new-privileges:true
read_only: true
cap_drop:
  - ALL
cap_add:
  - NET_BIND_SERVICE
```

**API Security:**

- Rate limiting on authentication endpoints
- CORS configuration for production domains
- SQL injection prevention with parameterized queries
- XSS protection with content security policies
- HTTPS enforcement with HSTS headers

## Performance Optimization Considerations

### Database Performance

**Hierarchical Query Optimization:**

```sql
-- Materialized paths for fast ancestor queries
SELECT * FROM tasks WHERE path <@ '1.2.3'::ltree;

-- Optimized subtree queries with depth limits
WITH RECURSIVE task_tree AS (
  SELECT id, parent_task_id, title, 0 as level
  FROM tasks WHERE id = $1
  UNION ALL
  SELECT t.id, t.parent_task_id, t.title, tt.level + 1
  FROM tasks t
  INNER JOIN task_tree tt ON t.parent_task_id = tt.id
  WHERE tt.level < 10  -- Prevent runaway recursion
)
SELECT * FROM task_tree ORDER BY level;
```

**Caching Strategy:**

- Redis for session storage and frequently accessed data
- PostgreSQL query result caching for expensive aggregations
- CDN for static assets and API responses where appropriate
- Application-level caching for user permissions and preferences

### Frontend Performance

**TanStack Query Optimization:**

```typescript
// Hierarchical cache key structure
export const taskQueries = {
  all: () => ["tasks"] as const,
  lists: () => [...taskQueries.all(), "list"] as const,
  list: (filters: TaskFilters) => [...taskQueries.lists(), filters] as const,
  details: () => [...taskQueries.all(), "detail"] as const,
  detail: (id: number) => [...taskQueries.details(), id] as const,
};

// Intelligent cache invalidation
function useCreateTask() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: createTask,
    onSuccess: (newTask) => {
      // Update list cache directly
      queryClient.setQueryData(
        taskQueries.list({ projectId: newTask.project_id }),
        (old: Task[]) => (old ? [...old, newTask] : [newTask]),
      );

      // Selective invalidation
      queryClient.invalidateQueries({
        predicate: (query) =>
          query.queryKey[0] === "tasks" && query.queryKey[1] === "list",
      });
    },
  });
}
```

**Bundle Optimization:**

- Code splitting at route level with React.lazy
- Tree shaking for unused library code
- Dynamic imports for large components
- Service worker for offline functionality and caching

This comprehensive implementation plan provides a roadmap for building a production-ready Todoist alternative with modern technologies and best practices. The phased approach ensures steady progress while maintaining code quality, security, and performance throughout development.
